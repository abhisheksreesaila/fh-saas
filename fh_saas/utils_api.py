# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_utils_api.ipynb.

# %% ../nbs/07_utils_api.ipynb 1
from __future__ import annotations
import httpx
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception
from typing import Optional, Dict, Any
import logging

logger = logging.getLogger(__name__)

# Custom retry condition: only retry on 429 or 500+ status codes
def _should_retry_on_status(exception):
    """Only retry on 429 rate limit or 500+ server errors"""
    if isinstance(exception, httpx.HTTPStatusError):
        return exception.response.status_code == 429 or exception.response.status_code >= 500
    if isinstance(exception, httpx.RequestError):
        return True  # Always retry network errors
    return False

# %% auto 0
__all__ = ['logger', 'AsyncAPIClient', 'bearer_token_auth', 'api_key_auth', 'oauth_token_auth']

# %% ../nbs/07_utils_api.ipynb 4
class AsyncAPIClient:
    """
    Async HTTP client with retry logic for external API integrations.
    
    Uses httpx for async requests and tenacity for exponential backoff on failures.
    Automatically retries on 429 (rate limit) and 500-level errors.
    
    Example:
        ```python
        client = AsyncAPIClient(
            base_url='https://api.example.com',
            auth_headers={'Authorization': 'Bearer TOKEN'},
            timeout=60
        )
        
        # GET request
        data = await client.get_json('/users', params={'page': 1})
        
        # POST request
        response = await client.request('POST', '/users', json={'name': 'Alice'})
        ```
    """
    
    def __init__(
        self, 
        base_url: str, # The root URL for the API
        auth_headers: dict = None, # Optional dictionary of auth headers (e.g., Authorization: Bearer TOKEN)
        timeout: int = 30 # Request timeout in seconds
    ):
        self.base_url = base_url.rstrip('/')
        self.auth_headers = auth_headers or {}
        self.timeout = timeout
        self.client = None
    
    async def __aenter__(self):
        """Async context manager entry - creates httpx client"""
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            headers=self.auth_headers,
            timeout=self.timeout
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit - closes httpx client"""
        if self.client:
            await self.client.aclose()
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception(_should_retry_on_status),
        reraise=True
    )
    async def request(
        self,
        method: str, # HTTP method (GET, POST, PUT, DELETE)
        endpoint: str, # API endpoint path (e.g., '/users')
        params: dict = None, # Query parameters
        json: dict = None, # JSON body for POST/PUT
        headers: dict = None # Additional headers to merge with auth_headers
    ) -> httpx.Response:
        """
        Execute HTTP request with automatic retry on transient failures.
        
        Retries up to 3 times with exponential backoff (2s, 4s, 8s) on:
        - 429 Too Many Requests (rate limiting)
        - 500-level server errors
        - Network errors (timeout, connection refused)
        
        Does NOT retry on 400-level errors (except 429).
        
        Args:
            method: HTTP method
            endpoint: API endpoint path
            params: Query parameters
            json: JSON request body
            headers: Additional headers
        
        Returns:
            httpx.Response: Response object
        
        Raises:
            httpx.HTTPStatusError: After 3 failed retries or immediately on 400-level errors
            httpx.RequestError: Network-level errors
        """
        if not self.client:
            raise RuntimeError("Client not initialized. Use 'async with' context manager.")
        
        # Merge additional headers
        request_headers = {**self.auth_headers, **(headers or {})}
        
        # Make request
        response = await self.client.request(
            method=method,
            url=endpoint,
            params=params,
            json=json,
            headers=request_headers
        )
        
        # Raise for any HTTP error status
        # The retry decorator will only retry on 429 or 500+ errors
        response.raise_for_status()
        
        return response
    
    async def get_json(
        self,
        endpoint: str, # API endpoint path
        params: dict = None # Query parameters
    ) -> Dict[str, Any]:
        """
        Convenience method for GET requests that return JSON.
        
        Args:
            endpoint: API endpoint path
            params: Query parameters
        
        Returns:
            Parsed JSON response as dict
        """
        response = await self.request('GET', endpoint, params=params)
        return response.json()

# %% ../nbs/07_utils_api.ipynb 9
def bearer_token_auth(token: str) -> dict:
    """
    Generate Bearer token authentication header.
    
    Args:
        token: API access token
    
    Returns:
        Dict with Authorization header
    
    Example:
        client = AsyncAPIClient(
            base_url='https://api.example.com',
            auth_headers=bearer_token_auth('my_token_123')
        )
    """
    return {'Authorization': f'Bearer {token}'}


def api_key_auth(
    api_key: str, # API key value
    header_name: str = 'X-API-Key' # Header name (default: X-API-Key)
) -> dict:
    """
    Generate API key authentication header.
    
    Args:
        api_key: API key value
        header_name: Custom header name (default: X-API-Key)
    
    Returns:
        Dict with API key header
    
    Example:
        # Standard X-API-Key
        auth = api_key_auth('my_key_123')
        
        # Custom header name
        auth = api_key_auth('my_key_123', 'X-Custom-API-Key')
    """
    return {header_name: api_key}


def oauth_token_auth(access_token: str) -> dict:
    """
    Generate OAuth 2.0 access token header (alias for bearer_token_auth).
    
    Args:
        access_token: OAuth 2.0 access token
    
    Returns:
        Dict with Authorization header
    """
    return bearer_token_auth(access_token)
