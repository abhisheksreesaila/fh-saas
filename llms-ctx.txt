FILE: _proc/00_db_host.html.md

---
title: db host models
---




<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L17){target="_blank" style="float:right; font-size:smaller"}

### gen_id

>      gen_id ()


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L16){target="_blank" style="float:right; font-size:smaller"}

### timestamp

>      timestamp ()


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L50){target="_blank" style="float:right; font-size:smaller"}

### SystemJob

>      SystemJob ()

*Maintenance: Provisioning & Cleanups*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L44){target="_blank" style="float:right; font-size:smaller"}

### HostAuditLog

>      HostAuditLog ()

*Security: Who changed the system?*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L37){target="_blank" style="float:right; font-size:smaller"}

### Subscription

>      Subscription ()

*Billing: Are they allowed to use the app?*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L31){target="_blank" style="float:right; font-size:smaller"}

### Membership

>      Membership ()

*Router: Which tenants can they access?*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L26){target="_blank" style="float:right; font-size:smaller"}

### TenantCatalog

>      TenantCatalog ()

*Registry: Where is the database?*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L20){target="_blank" style="float:right; font-size:smaller"}

### GlobalUser

>      GlobalUser ()

*Identity: Who is this person?*


## Singleton

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L59){target="_blank" style="float:right; font-size:smaller"}

### HostDatabase

>      HostDatabase (db_url:str=None)

*Singleton wrapper for host database connection and table objects.*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L94){target="_blank" style="float:right; font-size:smaller"}

### HostDatabase.from_env

>      HostDatabase.from_env ()

*Create HostDatabase from environment variables.*

Environment Variables:
    DB_TYPE: Database type (POSTGRESQL or SQLITE, default: POSTGRESQL)
    DB_USER: Database user (default: postgres)
    DB_PASS: Database password (required for PostgreSQL)
    DB_HOST: Database host (default: localhost)
    DB_PORT: Database port (default: 5432)
    DB_NAME: Database name (default: app_host)

Returns:
    HostDatabase: Singleton instance


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L126){target="_blank" style="float:right; font-size:smaller"}

### HostDatabase.commit

>      HostDatabase.commit ()

*Commit current transaction*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L130){target="_blank" style="float:right; font-size:smaller"}

### HostDatabase.rollback

>      HostDatabase.rollback ()

*Rollback current transaction*


---

### HostDatabase.mro

>      HostDatabase.mro ()

*Return a type's method resolution order.*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_host.py#L135){target="_blank" style="float:right; font-size:smaller"}

### HostDatabase.reset_instance

>      HostDatabase.reset_instance ()

*Reset singleton (for testing only)*




========================================

FILE: _proc/01_db_tenant.html.md

---
title: db tenant models
---




<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#81b63cfc .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_tenant.py#L15){target="_blank" style="float:right; font-size:smaller"}

### get_or_create_tenant_db

>      get_or_create_tenant_db (tenant_id:str, tenant_name:str=None)

*Get or create a tenant database:*
1. Check host DB if tenant exists
2. If not, create database and register in host
3. Return tenant Database connection


## Core Tenant Models

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_tenant.py#L136){target="_blank" style="float:right; font-size:smaller"}

### WebhookSecret

>      WebhookSecret ()

*Per-source webhook secrets for signature verification*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_tenant.py#L123){target="_blank" style="float:right; font-size:smaller"}

### WebhookEvent

>      WebhookEvent ()

*Webhook event log for idempotency and audit trail*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_tenant.py#L114){target="_blank" style="float:right; font-size:smaller"}

### TenantSettings

>      TenantSettings ()

*Tenant-wide configuration*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_tenant.py#L105){target="_blank" style="float:right; font-size:smaller"}

### TenantPermission

>      TenantPermission ()

*Fine-grained permissions for tenant users*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_tenant.py#L96){target="_blank" style="float:right; font-size:smaller"}

### TenantUser

>      TenantUser ()

*Local user profile in tenant (links to GlobalUser in host)*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/db_tenant.py#L148){target="_blank" style="float:right; font-size:smaller"}

### init_tenant_core_schema

>      init_tenant_core_schema (tenant_db:fastsql.core.Database)

*Create core tenant infrastructure tables with 'core_' prefix*




========================================

FILE: _proc/02_utils_sql.html.md

---
title: sql utilities
---



A comprehensive SQL helper library for database-heavy applications with:
- Centralized query registry
- Insert-only and upsert operations (single & bulk)
- CRUD utilities
- Multi-database support (PostgreSQL & SQLite)


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#fe897f1f .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## Database Type Detection

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L16){target="_blank" style="float:right; font-size:smaller"}

### get_db_type

>      get_db_type ()

*Get database type from environment variable*


## Query Executor & Parameter Validation

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L34){target="_blank" style="float:right; font-size:smaller"}

### run_id

>      run_id (db:fastsql.core.Database, registry:Dict[str,str], query_id:str,
>              params:Optional[Dict[str,Any]]=None)

*Execute a query by ID from a query registry*

Args:
    db: Database connection
    registry: Dictionary mapping query IDs to SQL strings
    query_id: Query identifier from registry
    params: Dictionary of parameters for the query

Returns:
    Query results

Raises:
    ValueError: If query_id not found or parameters missing

Example:
    SQL_REGISTRY = {"get_user": "SELECT * FROM users WHERE id = :user_id"}
    result = run_id(db, SQL_REGISTRY, "get_user", {"user_id": 123})


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L25){target="_blank" style="float:right; font-size:smaller"}

### validate_params

>      validate_params (sql:str, params:Dict[str,Any])

*Validate that all required parameters are provided*


## Insert-Only Operations

Insert new records only, skip existing ones without updating.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L120){target="_blank" style="float:right; font-size:smaller"}

### bulk_insert_only

>      bulk_insert_only (db:fastsql.core.Database, table_name:str,
>                        records:List[Dict[str,Any]], conflict_cols:List[str],
>                        auto_commit:bool=True)

*Insert multiple records only if they don't exist (ignores conflicts)*

OPTIMIZED: Uses executemany() for better performance with large datasets.
Processes all records in a single batch operation instead of individual inserts.

Difference from insert_only():
- insert_only(): Single record, one execute() call
- bulk_insert_only(): Multiple records, executemany() for 10-100x faster performance

Args:
    db: Database connection
    table_name: Name of the table
    records: List of dictionaries with column:value pairs
    conflict_cols: List of columns to check for conflicts
    auto_commit: If True, commits immediately. If False, caller must commit (default: True)

Example:
    bulk_insert_only(db, "transactions", [{"id": 1, "amount": 100}, ...], ["id"])


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L73){target="_blank" style="float:right; font-size:smaller"}

### insert_only

>      insert_only (db:fastsql.core.Database, table_name:str,
>                   record:Dict[str,Any], conflict_cols:List[str],
>                   auto_commit:bool=True)

*Insert a single record only if it doesn't exist (ignores conflicts)*

Args:
    db: Database connection
    table_name: Name of the table
    record: Dictionary of column:value pairs
    conflict_cols: List of columns to check for conflicts
    auto_commit: If True, commits immediately. If False, caller must commit (default: True)

Example:
    insert_only(db, "transactions", {"id": 1, "amount": 100}, ["id"])

    # Within a transaction context:
    with with_transaction(db):
        insert_only(db, "table1", {...}, ["id"], auto_commit=False)
        insert_only(db, "table2", {...}, ["id"], auto_commit=False)


## Upsert Operations

Insert new records or update existing ones.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L223){target="_blank" style="float:right; font-size:smaller"}

### bulk_upsert

>      bulk_upsert (db:fastsql.core.Database, table_name:str,
>                   records:List[Dict[str,Any]], conflict_cols:List[str],
>                   update_cols:Optional[List[str]]=None, auto_commit:bool=True)

*Insert multiple records or update if they exist (bulk upsert)*

OPTIMIZED: Uses executemany() for better performance with large datasets.

Difference from upsert():
- upsert(): Single record, one execute() call
- bulk_upsert(): Multiple records, executemany() for 10-100x faster performance

Args:
    db: Database connection
    table_name: Name of the table
    records: List of dictionaries with column:value pairs
    conflict_cols: List of columns to check for conflicts
    update_cols: Optional list of columns to update. If None, updates all non-conflict columns
    auto_commit: If True, commits immediately. If False, caller must commit (default: True)

Example:
    bulk_upsert(db, "transactions", [{"id": 1, "amount": 150}, ...], ["id"], ["amount"])


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L174){target="_blank" style="float:right; font-size:smaller"}

### upsert

>      upsert (db:fastsql.core.Database, table_name:str, record:Dict[str,Any],
>              conflict_cols:List[str], update_cols:Optional[List[str]]=None,
>              auto_commit:bool=True)

*Insert a record or update if it exists (upsert)*

Args:
    db: Database connection
    table_name: Name of the table
    record: Dictionary of column:value pairs
    conflict_cols: List of columns to check for conflicts
    update_cols: Optional list of columns to update. If None, updates all non-conflict columns
    auto_commit: If True, commits immediately. If False, caller must commit (default: True)

Example:
    upsert(db, "transactions", {"id": 1, "amount": 150}, ["id"], ["amount"])


## CRUD Operations

Standard Create, Read, Update, Delete operations.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L364){target="_blank" style="float:right; font-size:smaller"}

### bulk_delete

>      bulk_delete (db:fastsql.core.Database, table_name:str, id_list:List[Any],
>                   id_col:str='id', auto_commit:bool=True)

*Delete multiple records by ID list*

Args:
    db: Database connection
    table_name: Name of the table
    id_list: List of ID values to delete
    id_col: Name of the ID column (default: "id")
    auto_commit: If True, commits immediately. If False, caller must commit (default: True)

Example:
    bulk_delete(db, "transactions", [1, 2, 3, 4, 5], "transaction_id")


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L339){target="_blank" style="float:right; font-size:smaller"}

### delete_record

>      delete_record (db:fastsql.core.Database, table_name:str, id_value:Any,
>                     id_col:str='id', auto_commit:bool=True)

*Delete a single record by ID*

Args:
    db: Database connection
    table_name: Name of the table
    id_value: Value of the ID to delete
    id_col: Name of the ID column (default: "id")
    auto_commit: If True, commits immediately. If False, caller must commit (default: True)

Example:
    delete_record(db, "transactions", 123, "transaction_id")


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L306){target="_blank" style="float:right; font-size:smaller"}

### update_record

>      update_record (db:fastsql.core.Database, table_name:str, id_value:Any,
>                     id_col:str='id', auto_commit:bool=True, **updates)

*Update a single record by ID*

Args:
    db: Database connection
    table_name: Name of the table
    id_value: Value of the ID to update
    id_col: Name of the ID column (default: "id")
    auto_commit: If True, commits immediately. If False, caller must commit (default: True)
    **updates: Column=value pairs to update

Example:
    update_record(db, "transactions", 123, "transaction_id", amount=200, status="completed")


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L283){target="_blank" style="float:right; font-size:smaller"}

### get_by_id

>      get_by_id (db:fastsql.core.Database, table_name:str, id_value:Any,
>                 id_col:str='id')

*Get a single record by ID*

Args:
    db: Database connection
    table_name: Name of the table
    id_value: Value of the ID to search for
    id_col: Name of the ID column (default: "id")

Returns:
    Query result

Example:
    result = get_by_id(db, "transactions", 123, "transaction_id")


## Helper Utilities

Transaction management, pagination, and other utilities.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L439){target="_blank" style="float:right; font-size:smaller"}

### batch_execute

>      batch_execute (db:fastsql.core.Database, operation_func, items:List[Any],
>                     batch_size:int=100)

*Execute an operation on items in batches with commits after each batch*

Args:
    db: Database connection
    operation_func: Function to call for each item (takes db and item as args)
    items: List of items to process
    batch_size: Number of items per batch (default: 100)

Example:
    def insert_item(db, item):
        insert_only(db, "transactions", item, ["id"])

    batch_execute(db, insert_item, large_list_of_records, batch_size=50)


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L420){target="_blank" style="float:right; font-size:smaller"}

### paginate_sql

>      paginate_sql (sql:str, page:int, page_size:int)

*Add pagination to a SQL query*

Args:
    sql: Base SQL query
    page: Page number (1-indexed)
    page_size: Number of records per page

Returns:
    SQL with LIMIT and OFFSET added

Example:
    paginated = paginate_sql("SELECT * FROM transactions", 2, 50)
    # Returns: "SELECT * FROM transactions LIMIT 50 OFFSET 50"


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sql.py#L400){target="_blank" style="float:right; font-size:smaller"}

### with_transaction

>      with_transaction (db:fastsql.core.Database)

*Context manager for safe transaction handling with auto-rollback on error*

IMPORTANT: When using this context manager, set auto_commit=False on all
database operations inside the block to allow proper rollback behavior.

Example:
    with with_transaction(db):
        insert_only(db, "table1", {...}, ["id"], auto_commit=False)
        update_record(db, "table2", 123, auto_commit=False, amount=200)
        # Automatically commits if no errors, rolls back on exception




========================================

FILE: _proc/15_utils_db.html.md

---
title: Database Utilities
---



Atomic table and index management utilities for tenant databases.

- **Table Registration**: Create app-specific tables from dataclass models (fastsql pattern)
- **Index Management**: Create/drop indexes with dialect-specific SQL
- **Atomic Operations**: All operations commit on success, rollback on failure with specific error messages


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#0c746a62 .cell execution_count=41}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## Table Registration

Create app-specific tables from dataclass models using fastsql's `db.create()` pattern.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_db.py#L13){target="_blank" style="float:right; font-size:smaller"}

### register_table

>      register_table (tenant_db:fastsql.core.Database, model_class:Type,
>                      table_name:str, pk:str='id')

*Create a table from a dataclass model if it doesn't exist (atomic operation).*

Uses fastsql's db.create() which handles CREATE TABLE IF NOT EXISTS internally.
Commits on success, rolls back on failure with specific error message.

Args:
    tenant_db: Database connection to tenant database
    model_class: Dataclass defining the table schema
    table_name: Name of the table to create
    pk: Primary key column name (default: 'id')

Returns:
    Table object for CRUD operations (fastsql table)

Example:
    class Transaction:
        id: str
        amount: float
        date: str
        category: str = None

    tenant_db = get_or_create_tenant_db("tenant_123")
    transactions = register_table(tenant_db, Transaction, "transactions")

    # Now use the table object for CRUD
    transactions.insert(Transaction(id="t1", amount=100.0, date="2024-01-01"))


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_db.py#L51){target="_blank" style="float:right; font-size:smaller"}

### register_tables

>      register_tables (tenant_db:fastsql.core.Database,
>                       models:List[Tuple[Type,str,str]])

*Create multiple tables atomically (all succeed or all rollback).*

Args:
    tenant_db: Database connection to tenant database
    models: List of tuples: [(ModelClass, table_name, pk), ...]

Returns:
    Dictionary mapping table names to table objects: {table_name: table_object}

Example:
    class Transaction:
        id: str; amount: float; date: str

    class Connection:
        id: str; provider: str; status: str

    tenant_db = get_or_create_tenant_db("tenant_123")
    tables = register_tables(tenant_db, [
        (Transaction, "transactions", "id"),
        (Connection, "connections", "id"),
    ])

    # Access table objects
    tables["transactions"].insert(...)
    tables["connections"].insert(...)


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_db.py#L92){target="_blank" style="float:right; font-size:smaller"}

### drop_table

>      drop_table (tenant_db:fastsql.core.Database, table_name:str)

*Drop a table if it exists (atomic operation).*

Args:
    tenant_db: Database connection to tenant database
    table_name: Name of the table to drop

Example:
    drop_table(tenant_db, "transactions")


## Index Management

Create and drop indexes with dialect-specific SQL (PostgreSQL/SQLite).

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_db.py#L112){target="_blank" style="float:right; font-size:smaller"}

### create_index

>      create_index (tenant_db:fastsql.core.Database, table_name:str,
>                    columns:List[str], unique:bool=False, index_name:str=None)

*Create an index on a table if it doesn't exist (atomic operation).*

Args:
    tenant_db: Database connection to tenant database
    table_name: Name of the table
    columns: List of column names to index
    unique: If True, creates a UNIQUE index (default: False)
    index_name: Custom index name. If None, auto-generates: idx_{table}_{col1}_{col2}

Example:
    # Simple index
    create_index(tenant_db, "transactions", ["date"])

    # Composite unique index
    create_index(tenant_db, "transactions", ["account_id", "external_id"], unique=True)

    # Custom name
    create_index(tenant_db, "transactions", ["category"], index_name="idx_txn_cat")


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_db.py#L152){target="_blank" style="float:right; font-size:smaller"}

### create_indexes

>      create_indexes (tenant_db:fastsql.core.Database,
>                      indexes:List[Tuple[str,List[str],bool,Optional[str]]])

*Create multiple indexes atomically (all succeed or all rollback).*

Args:
    tenant_db: Database connection to tenant database
    indexes: List of tuples: [(table_name, columns, unique, index_name), ...]
             index_name can be None for auto-generated names

Example:
    create_indexes(tenant_db, [
        ("transactions", ["date"], False, None),
        ("transactions", ["account_id", "external_id"], True, "idx_txn_unique"),
        ("connections", ["provider"], False, None),
    ])


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_db.py#L189){target="_blank" style="float:right; font-size:smaller"}

### drop_index

>      drop_index (tenant_db:fastsql.core.Database, index_name:str,
>                  table_name:str=None)

*Drop an index if it exists (atomic operation).*

Args:
    tenant_db: Database connection to tenant database
    index_name: Name of the index to drop
    table_name: Table name (required for PostgreSQL, optional for SQLite)

Example:
    drop_index(tenant_db, "idx_transactions_date", "transactions")


## Schema Introspection

Check if tables exist in the database.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_db.py#L218){target="_blank" style="float:right; font-size:smaller"}

### table_exists

>      table_exists (tenant_db:fastsql.core.Database, table_name:str)

*Check if a table exists in the database.*

Args:
    tenant_db: Database connection to tenant database
    table_name: Name of the table to check

Returns:
    True if table exists, False otherwise

Example:
    if not table_exists(tenant_db, "transactions"):
        transactions = register_table(tenant_db, Transaction, "transactions")


## Usage Example

Complete workflow: Define dataclass models → Get tenant DB → Register tables → Create indexes

## Tests



========================================

FILE: _proc/04_utils_oauth.html.md

---
Current: users must re-login after expiry
Future: implement refresh token flow for seamless re-authentication
New users auto-create their own tenant (future: payment screen)
description: Multi-user tenant authentication with Google OAuth, CSRF protection,
  and automatic tenant provisioning.
output-file: utils_oauth.html
title: oauth utils

---


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#4c01a905 .cell execution_count=3}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## OAuth Client Setup

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L35){target="_blank" style="float:right; font-size:smaller"}

### get_google_oauth_client

>      get_google_oauth_client ()

*Initialize Google OAuth client with credentials from environment.*

Returns:
    GoogleAppClient: Configured OAuth client

Environment Variables Required:
    GOOGLE_CLIENT_ID: OAuth client ID from Google Cloud Console
    GOOGLE_CLIENT_SECRET: OAuth client secret

Note:
    Redirect URI must be registered in Google Cloud Console:
    - Development: http://localhost:8000/auth/callback
    - Production: https://yourdomain.com/auth/callback


## CSRF Protection

### Why CSRF Protection?

**Attack Scenario Without CSRF:**
1. Attacker initiates OAuth flow, gets auth code
2. Attacker sends victim link: `yourapp.com/auth/callback?code=ATTACKER_CODE`
3. Victim clicks link → your app creates session for attacker's account
4. Victim enters sensitive data thinking they're in their own account
5. Attacker sees all victim's data in attacker's account

**Solution: State Token**
- Generate random UUID when user clicks login
- Store in session, pass to Google via state parameter
- Google includes state in callback URL
- Verify state matches before creating session
- If mismatch → reject (prevents attacker code injection)

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L81){target="_blank" style="float:right; font-size:smaller"}

### verify_oauth_state

>      verify_oauth_state (session:dict, callback_state:str)

*Verify OAuth callback state matches stored session state (CSRF protection).*

Args:
    session: Starlette session dict containing 'oauth_state'
    callback_state: State parameter from OAuth callback URL

Raises:
    ValueError: If state missing from session or mismatch detected

Security:
    Always call this BEFORE exchanging auth code for tokens.
    Prevents CSRF attacks where attacker injects their auth code.


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L66){target="_blank" style="float:right; font-size:smaller"}

### generate_oauth_state

>      generate_oauth_state ()

*Generate cryptographically secure random state token for CSRF protection.*

Returns:
    str: Random UUID hex string (32 characters)

Usage:
    state = generate_oauth_state()
    session['oauth_state'] = state
    login_link = client.login_link(state=state)


## User Management

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L231){target="_blank" style="float:right; font-size:smaller"}

### verify_membership

>      verify_membership (host_db:fh_saas.db_host.HostDatabase, user_id:str,
>                         tenant_id:str,
>                         log_handler:fh_saas.utils_log.DatabaseHandler=None)

*Verify user has active membership for specific tenant.*

Args:
    host_db: HostDatabase instance (singleton)
    user_id: GlobalUser.id from session
    tenant_id: TenantCatalog.id from session
    log_handler: Optional DatabaseHandler for logging

Returns:
    bool: True if active membership exists, False otherwise

Security:
    MUST be called before granting access to tenant database.
    Prevents cross-tenant data access by validating membership.
    Read-only operation: no transaction management needed


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L199){target="_blank" style="float:right; font-size:smaller"}

### get_user_membership

>      get_user_membership (host_db:fh_saas.db_host.HostDatabase, user_id:str,
>                           log_handler:fh_saas.utils_log.DatabaseHandler=None)

*Get single active membership for user.*

Args:
    host_db: HostDatabase instance (singleton)
    user_id: GlobalUser.id from host database
    log_handler: Optional DatabaseHandler for logging

Returns:
    Membership | None: Active membership record or None if not found

Note:
    Current design: one user = one tenant (enforced in code)
    Returns first active membership found
    Read-only operation: no transaction management needed
    Future: May add multi-tenant support with tenant selector


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L114){target="_blank" style="float:right; font-size:smaller"}

### create_or_get_global_user

>      create_or_get_global_user (host_db:fh_saas.db_host.HostDatabase,
>                                 oauth_id:str, email:str, oauth_info:dict=None,
>                                 log_handler:fh_saas.utils_log.DatabaseHandler=
>                                 None)

*Create or retrieve GlobalUser from host database.*

Args:
    host_db: HostDatabase instance (singleton)
    oauth_id: Unique identifier from OAuth provider (Google 'sub' field)
    email: User's email address
    oauth_info: Full OAuth user info dict (for future use)
    log_handler: Optional DatabaseHandler for logging

Returns:
    GlobalUser: User record from host database

Note:
    - Updates last_login timestamp on every call
    - Google tokens expire after 1 hour (user must re-login)
    - Caller must commit transaction after calling this function
    - Future: Store refresh_token for auto-refresh


## Membership & Tenant Access

## Auto-Provisioning (New User Onboarding)

When a new user logs in for the first time:
1. Create physical tenant database (PostgreSQL)
2. Register tenant in host catalog
3. Create membership linking user to tenant
4. Create TenantUser profile in tenant database
5. Initialize core tenant schema (users, permissions, settings)

**Future Enhancement:** Insert payment screen before step 1

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L267){target="_blank" style="float:right; font-size:smaller"}

### provision_new_user

>      provision_new_user (host_db:fh_saas.db_host.HostDatabase,
>                          global_user:fh_saas.db_host.GlobalUser,
>                          log_handler:fh_saas.utils_log.DatabaseHandler=None)

*Auto-provision new tenant for first-time user with transaction management.*

Args:
    host_db: HostDatabase instance (singleton)
    global_user: GlobalUser record from host database
    log_handler: Optional DatabaseHandler for logging

Returns:
    str: Tenant ID of newly created tenant

Creates:
    - Physical tenant database (PostgreSQL or SQLite)
    - TenantCatalog entry in host database
    - Membership linking user to tenant (role='owner')
    - TenantUser profile in tenant database (local_role='admin')
    - Core tenant schema (users, permissions, settings tables)
    - Audit log entry in host database

Transaction Handling:
    - Commits all host database changes on success
    - Rolls back host database on any failure
    - Logs all operations for audit trail

Future:
    - Add payment screen before database creation
    - Send welcome email with onboarding steps


## Session Management

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L449){target="_blank" style="float:right; font-size:smaller"}

### clear_session

>      clear_session (session:dict)

*Clear all session data (logout).*

Args:
    session: Starlette session dict to clear

Note:
    Removes all keys, not just auth-related ones.
    User will need to re-authenticate on next request.


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L422){target="_blank" style="float:right; font-size:smaller"}

### get_current_user

>      get_current_user (session:dict)

*Extract current user info from session.*

Args:
    session: Starlette session dict

Returns:
    dict | None: User info dict or None if not authenticated

Usage:
    user = get_current_user(session)
    if not user:
        return RedirectResponse('/login', status_code=303)


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L393){target="_blank" style="float:right; font-size:smaller"}

### create_user_session

>      create_user_session (session:dict,
>                           global_user:fh_saas.db_host.GlobalUser,
>                           membership:fh_saas.db_host.Membership)

*Create authenticated session after successful OAuth login.*

Args:
    session: Starlette session dict to populate
    global_user: Authenticated user from host database
    membership: User's tenant membership record

Session Keys Set:
    user_id: GlobalUser.id (for host database queries)
    email: User's email address (for display)
    tenant_id: TenantCatalog.id (determines database connection)
    tenant_role: Membership.role (owner/admin/member)
    is_sys_admin: GlobalUser.is_sys_admin (host access flag)
    login_at: ISO timestamp of session creation

Security:
    Session is cryptographically signed by Starlette.
    User cannot tamper with session values.


## Route Helpers & Authorization

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L492){target="_blank" style="float:right; font-size:smaller"}

### require_tenant_access

>      require_tenant_access (session:dict)

*Validate user has access to tenant from session.*

Args:
    session: Starlette session dict

Returns:
    Database: Tenant database connection

Raises:
    ValueError: If user not authenticated
    PermissionError: If membership invalid or inactive

Security:
    CRITICAL: Call this at start of every tenant route handler.
    Verifies membership before granting database access.
    Prevents cross-tenant data access attacks.

Usage:
    @app.get('/tenant/transactions')
    def get_transactions(session):
        tenant_db = require_tenant_access(session)
        # Now safe to query tenant database
        return tenant_db.t.transactions()


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L463){target="_blank" style="float:right; font-size:smaller"}

### route_user_after_login

>      route_user_after_login (global_user:fh_saas.db_host.GlobalUser,
>                              membership:fh_saas.db_host.Membership=None)

*Determine redirect URL based on user type and membership.*

Args:
    global_user: Authenticated user from host database
    membership: User's tenant membership (None for sys admins)

Returns:
    str: Redirect URL path

Routing Logic:
    - System admin (is_sys_admin=True) → /admin/dashboard
    - Tenant user with membership → /dashboard
    - User without membership → Error (should have been provisioned)


## OAuth Route Handlers (Pseudo-code)

These functions show how to integrate with FastHTML routes.
Actual route implementation will be in main app file.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L628){target="_blank" style="float:right; font-size:smaller"}

### handle_logout

>      handle_logout (session)

*Handle /logout route - clear session and redirect to login.*

Usage in FastHTML:
    @app.get('/logout')
    def logout(session):
        return handle_logout(session)

Returns:
    RedirectResponse: Redirect to login page


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L563){target="_blank" style="float:right; font-size:smaller"}

### handle_oauth_callback

>      handle_oauth_callback (code:str, state:str, request, session)

*Handle /auth/callback route - complete OAuth flow with CSRF validation.*

Usage in FastHTML:
    @app.get('/auth/callback')
    def auth_callback(code: str, state: str, request, session):
        return handle_oauth_callback(code, state, request, session)

Args:
    code: Authorization code from Google
    state: CSRF state token from Google (should match session)
    request: Starlette request object
    session: Starlette session dict

Returns:
    RedirectResponse: Redirect to appropriate dashboard

Security:
    1. Verify CSRF state (prevents session hijacking)
    2. Exchange code for user info
    3. Create/get GlobalUser
    4. Check membership or provision new tenant
    5. Create session
    6. Redirect based on user type


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_oauth.py#L539){target="_blank" style="float:right; font-size:smaller"}

### handle_login_request

>      handle_login_request (request, session)

*Handle /login route - generate OAuth link with CSRF protection.*

Usage in FastHTML:
    @app.get('/login')
    def login(request, session):
        return handle_login_request(request, session)

Returns:
    str: Google OAuth authorization URL with state parameter




========================================

FILE: _proc/07_utils_api.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#de98629e .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## AsyncAPIClient

Async HTTP client for API requests with automatic retry logic for transient failures (429, 500-level errors).

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_api.py#L25){target="_blank" style="float:right; font-size:smaller"}

### AsyncAPIClient

>      AsyncAPIClient (base_url:str, auth_headers:dict=None, timeout:int=30)

*Async HTTP client with retry logic for external API integrations.*

Uses httpx for async requests and tenacity for exponential backoff on failures.
Automatically retries on 429 (rate limit) and 500-level errors.

Example:
    ```python
    client = AsyncAPIClient(
        base_url='https://api.example.com',
        auth_headers={'Authorization': 'Bearer TOKEN'},
        timeout=60
    )

    # GET request
    data = await client.get_json('/users', params={'page': 1})

    # POST request
    response = await client.request('POST', '/users', json={'name': 'Alice'})
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| base_url | str |  | The root URL for the API |
| auth_headers | dict | None | Optional dictionary of auth headers (e.g., Authorization: Bearer TOKEN) |
| timeout | int | 30 | Request timeout in seconds |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_api.py#L48){target="_blank" style="float:right; font-size:smaller"}

### AsyncAPIClient.__init__

>      AsyncAPIClient.__init__ (base_url:str, auth_headers:dict=None,
>                               timeout:int=30)

*Initialize self.  See help(type(self)) for accurate signature.*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| base_url | str |  | The root URL for the API |
| auth_headers | dict | None | Optional dictionary of auth headers (e.g., Authorization: Bearer TOKEN) |
| timeout | int | 30 | Request timeout in seconds |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_api.py#L79){target="_blank" style="float:right; font-size:smaller"}

### AsyncAPIClient.request

>      AsyncAPIClient.request (method:str, endpoint:str, params:dict=None,
>                              json:dict=None, headers:dict=None)

*Execute HTTP request with automatic retry on transient failures.*

Retries up to 3 times with exponential backoff (2s, 4s, 8s) on:
- 429 Too Many Requests (rate limiting)
- 500-level server errors
- Network errors (timeout, connection refused)

Does NOT retry on 400-level errors (except 429).

Args:
    method: HTTP method
    endpoint: API endpoint path
    params: Query parameters
    json: JSON request body
    headers: Additional headers

Returns:
    httpx.Response: Response object

Raises:
    httpx.HTTPStatusError: After 3 failed retries or immediately on 400-level errors
    httpx.RequestError: Network-level errors

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| method | str |  | HTTP method (GET, POST, PUT, DELETE) |
| endpoint | str |  | API endpoint path (e.g., '/users') |
| params | dict | None | Query parameters |
| json | dict | None | JSON body for POST/PUT |
| headers | dict | None | Additional headers to merge with auth_headers |
| **Returns** | **Response** |  |  |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_api.py#L132){target="_blank" style="float:right; font-size:smaller"}

### AsyncAPIClient.get_json

>      AsyncAPIClient.get_json (endpoint:str, params:dict=None)

*Convenience method for GET requests that return JSON.*

Args:
    endpoint: API endpoint path
    params: Query parameters

Returns:
    Parsed JSON response as dict

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| endpoint | str |  | API endpoint path |
| params | dict | None | Query parameters |
| **Returns** | **Dict** |  |  |


## Auth Helpers

Common authentication header patterns for popular APIs.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_api.py#L151){target="_blank" style="float:right; font-size:smaller"}

### bearer_token_auth

>      bearer_token_auth (token:str)

*Generate Bearer token authentication header.*

Args:
    token: API access token

Returns:
    Dict with Authorization header

Example:
    client = AsyncAPIClient(
        base_url='https://api.example.com',
        auth_headers=bearer_token_auth('my_token_123')
    )


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_api.py#L170){target="_blank" style="float:right; font-size:smaller"}

### api_key_auth

>      api_key_auth (api_key:str, header_name:str='X-API-Key')

*Generate API key authentication header.*

Args:
    api_key: API key value
    header_name: Custom header name (default: X-API-Key)

Returns:
    Dict with API key header

Example:
    # Standard X-API-Key
    auth = api_key_auth('my_key_123')

    # Custom header name
    auth = api_key_auth('my_key_123', 'X-Custom-API-Key')

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| api_key | str |  | API key value |
| header_name | str | X-API-Key | Header name (default: X-API-Key) |
| **Returns** | **dict** |  |  |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_api.py#L194){target="_blank" style="float:right; font-size:smaller"}

### oauth_token_auth

>      oauth_token_auth (access_token:str)

*Generate OAuth 2.0 access token header (alias for bearer_token_auth).*

Args:
    access_token: OAuth 2.0 access token

Returns:
    Dict with Authorization header




========================================

FILE: _proc/08_utils_graphql.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#39888331 .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## GraphQLClient

GraphQL client with streaming pagination - yields batches of data instead of loading entire dataset into memory.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_graphql.py#L15){target="_blank" style="float:right; font-size:smaller"}

### GraphQLClient

>      GraphQLClient (api_client:fh_saas.utils_api.AsyncAPIClient,
>                     endpoint:str='')

*GraphQL client with streaming pagination for memory-efficient data fetching.*

Uses async generators to yield data page-by-page instead of accumulating
full result sets in memory. Ideal for large datasets (millions of rows).

Example:
    ```python
    from fh_saas.utils_api import AsyncAPIClient, bearer_token_auth

    async with AsyncAPIClient(
        'https://api.example.com/graphql',
        auth_headers=bearer_token_auth('TOKEN')
    ) as http_client:

        client = GraphQLClient(http_client)

        # Single query
        result = await client.execute_query(
            query='{ users { id name } }'
        )

        # Paginated streaming
        async for batch in client.fetch_pages_generator(
            query_template='''
                query($cursor: String) {
                    users(after: $cursor) {
                        nodes { id name email }
                        pageInfo { hasNextPage endCursor }
                    }
                }
            ''',
            variables={'cursor': None},
            items_path=['data', 'users', 'nodes'],
            cursor_path=['data', 'users', 'pageInfo', 'endCursor']
        ):
            print(f"Processing batch of {len(batch)} records")
            # Process batch immediately, never load full dataset
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| api_client | AsyncAPIClient |  | Initialized AsyncAPIClient instance |
| endpoint | str |  | GraphQL endpoint path (default: '' for base URL) |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_graphql.py#L57){target="_blank" style="float:right; font-size:smaller"}

### GraphQLClient.__init__

>      GraphQLClient.__init__ (api_client:fh_saas.utils_api.AsyncAPIClient,
>                              endpoint:str='')

*Initialize self.  See help(type(self)) for accurate signature.*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| api_client | AsyncAPIClient |  | Initialized AsyncAPIClient instance |
| endpoint | str |  | GraphQL endpoint path (default: '' for base URL) |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_graphql.py#L65){target="_blank" style="float:right; font-size:smaller"}

### GraphQLClient.execute_query

>      GraphQLClient.execute_query (query:str, variables:dict=None)

*Execute a single GraphQL query.*

Args:
    query: GraphQL query string
    variables: Optional query variables

Returns:
    Full JSON response from GraphQL endpoint

Raises:
    ValueError: If GraphQL response contains 'errors' key

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| query | str |  | GraphQL query string |
| variables | dict | None | Query variables |
| **Returns** | **Dict** |  |  |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_graphql.py#L102){target="_blank" style="float:right; font-size:smaller"}

### GraphQLClient.execute_mutation

>      GraphQLClient.execute_mutation (mutation:str, variables:dict=None)

*Execute a GraphQL mutation (alias for execute_query).*

Args:
    mutation: GraphQL mutation string
    variables: Optional mutation variables

Returns:
    Full JSON response from GraphQL endpoint

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| mutation | str |  | GraphQL mutation string |
| variables | dict | None | Mutation variables |
| **Returns** | **Dict** |  |  |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_graphql.py#L119){target="_blank" style="float:right; font-size:smaller"}

### GraphQLClient.fetch_pages_generator

>      GraphQLClient.fetch_pages_generator (query_template:str, variables:dict,
>                                           items_path:list[str],
>                                           cursor_path:list[str],
>                                           has_next_path:list[str]=None,
>                                           cursor_var:str='cursor')

*Stream paginated GraphQL data page-by-page using async generator.*

CRITICAL: Yields batches of data instead of accumulating in memory.
For large datasets (millions of rows), this prevents OOM errors.

Args:
    query_template: GraphQL query with $cursor variable
    variables: Initial variables (e.g., {'cursor': None})
    items_path: Path to data list in response (e.g., ['data', 'users', 'nodes'])
    cursor_path: Path to next cursor (e.g., ['data', 'users', 'pageInfo', 'endCursor'])
    has_next_path: Optional path to hasNextPage flag
    cursor_var: Cursor variable name in query

Yields:
    List[Dict]: One batch of records per page

Example:
    ```python
    async for batch in client.fetch_pages_generator(
        query_template='''
            query($cursor: String) {
                users(after: $cursor, first: 1000) {
                    nodes { id name }
                    pageInfo { hasNextPage endCursor }
                }
            }
        ''',
        variables={'cursor': None},
        items_path=['data', 'users', 'nodes'],
        cursor_path=['data', 'users', 'pageInfo', 'endCursor'],
        has_next_path=['data', 'users', 'pageInfo', 'hasNextPage']
    ):
        # Process this batch immediately
        df = pl.DataFrame(batch)
        df.write_database('staging_table', ...)
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| query_template | str |  | GraphQL query with $variables placeholders |
| variables | dict |  | Initial variables (must include cursor key) |
| items_path | list |  | JSONPath to list of items (e.g., ['data', 'users', 'nodes']) |
| cursor_path | list |  | JSONPath to next cursor (e.g., ['data', 'users', 'pageInfo', 'endCursor']) |
| has_next_path | list | None | Optional path to hasNextPage boolean (if None, checks cursor != None) |
| cursor_var | str | cursor | Variable name for cursor in query (default: 'cursor') |
| **Returns** | **AsyncGenerator** |  |  |




========================================

FILE: _proc/14_utils_webhook.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Signature Verification

::: {#8dde5d59 .cell}
``` {.python .cell-code}
from nbdev.showdoc import *
```
:::


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L19){target="_blank" style="float:right; font-size:smaller"}

### verify_webhook_signature

>      verify_webhook_signature (payload:str, signature:str,
>                                secret:Optional[str]=None)

*Verify HMAC-SHA256 signature for webhook payload. Returns True if valid.*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| payload | str |  | Raw request body as string |
| signature | str |  | Signature from header (format: "sha256=<hex>") |
| secret | Optional | None | Secret key, defaults to WEBHOOK_SECRET env var |
| **Returns** | **bool** |  |  |


## Idempotency Checking

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L44){target="_blank" style="float:right; font-size:smaller"}

### check_idempotency

>      check_idempotency (db:fastsql.core.Database, idempotency_key:str)

*Check if webhook event already processed. Returns True if duplicate.*

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| db | Database | Tenant database connection |
| idempotency_key | str | Unique key for this webhook event |
| **Returns** | **bool** |  |


## Webhook Event Logging

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L56){target="_blank" style="float:right; font-size:smaller"}

### log_webhook_event

>      log_webhook_event (db:fastsql.core.Database, webhook_id:str, source:str,
>                         event_type:str, payload:Dict[str,Any], signature:str,
>                         idempotency_key:str, status:str='pending')

*Log webhook event to database*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| db | Database |  | Tenant database connection |
| webhook_id | str |  | Unique webhook ID |
| source | str |  | Source system (e.g., "stripe", "github") |
| event_type | str |  | Event type (e.g., "payment.success") |
| payload | Dict |  | Full webhook payload |
| signature | str |  | Request signature |
| idempotency_key | str |  | Idempotency key |
| status | str | pending | Status: pending, processing, completed, failed |


## Update Webhook Status

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L79){target="_blank" style="float:right; font-size:smaller"}

### update_webhook_status

>      update_webhook_status (db:fastsql.core.Database, webhook_id:str,
>                             status:str, error_message:Optional[str]=None)

*Update webhook event status and processed timestamp*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| db | Database |  | Tenant database connection |
| webhook_id | str |  | Webhook ID to update |
| status | str |  | New status |
| error_message | Optional | None | Optional error message |


## Process Webhook

Main entry point for processing webhooks. Orchestrates verification, idempotency checking, and execution.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L96){target="_blank" style="float:right; font-size:smaller"}

### process_webhook

>      process_webhook (db:fastsql.core.Database, webhook_id:str, source:str,
>                       event_type:str, payload:Dict[str,Any], signature:str,
>                       idempotency_key:str, raw_body:str, handler:Callable,
>                       secret:Optional[str]=None)

*Process webhook with verification, idempotency, and custom handler execution*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| db | Database |  | Tenant database connection |
| webhook_id | str |  | Unique webhook ID |
| source | str |  | Source system |
| event_type | str |  | Event type |
| payload | Dict |  | Webhook payload |
| signature | str |  | Request signature |
| idempotency_key | str |  | Idempotency key |
| raw_body | str |  | Raw request body for signature verification |
| handler | Callable |  | App-specific webhook handler function |
| secret | Optional | None | Optional webhook secret |
| **Returns** | **Dict** |  |  |


::: {#6dd1a371 .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L19){target="_blank" style="float:right; font-size:smaller"}

### verify_webhook_signature

>      verify_webhook_signature (payload:str, signature:str,
>                                secret:Optional[str]=None)

*Verify HMAC-SHA256 signature for webhook payload. Returns True if valid.*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| payload | str |  | Raw request body as string |
| signature | str |  | Signature from header (format: "sha256=<hex>") |
| secret | Optional | None | Secret key, defaults to WEBHOOK_SECRET env var |
| **Returns** | **bool** |  |  |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L44){target="_blank" style="float:right; font-size:smaller"}

### check_idempotency

>      check_idempotency (db:fastsql.core.Database, idempotency_key:str)

*Check if webhook event already processed. Returns True if duplicate.*

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| db | Database | Tenant database connection |
| idempotency_key | str | Unique key for this webhook event |
| **Returns** | **bool** |  |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L56){target="_blank" style="float:right; font-size:smaller"}

### log_webhook_event

>      log_webhook_event (db:fastsql.core.Database, webhook_id:str, source:str,
>                         event_type:str, payload:Dict[str,Any], signature:str,
>                         idempotency_key:str, status:str='pending')

*Log webhook event to database*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| db | Database |  | Tenant database connection |
| webhook_id | str |  | Unique webhook ID |
| source | str |  | Source system (e.g., "stripe", "github") |
| event_type | str |  | Event type (e.g., "payment.success") |
| payload | Dict |  | Full webhook payload |
| signature | str |  | Request signature |
| idempotency_key | str |  | Idempotency key |
| status | str | pending | Status: pending, processing, completed, failed |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L79){target="_blank" style="float:right; font-size:smaller"}

### update_webhook_status

>      update_webhook_status (db:fastsql.core.Database, webhook_id:str,
>                             status:str, error_message:Optional[str]=None)

*Update webhook event status and processed timestamp*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| db | Database |  | Tenant database connection |
| webhook_id | str |  | Webhook ID to update |
| status | str |  | New status |
| error_message | Optional | None | Optional error message |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L96){target="_blank" style="float:right; font-size:smaller"}

### process_webhook

>      process_webhook (db:fastsql.core.Database, webhook_id:str, source:str,
>                       event_type:str, payload:Dict[str,Any], signature:str,
>                       idempotency_key:str, raw_body:str, handler:Callable,
>                       secret:Optional[str]=None)

*Process webhook with verification, idempotency, and custom handler execution*

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| db | Database |  | Tenant database connection |
| webhook_id | str |  | Unique webhook ID |
| source | str |  | Source system |
| event_type | str |  | Event type |
| payload | Dict |  | Webhook payload |
| signature | str |  | Request signature |
| idempotency_key | str |  | Idempotency key |
| raw_body | str |  | Raw request body for signature verification |
| handler | Callable |  | App-specific webhook handler function |
| secret | Optional | None | Optional webhook secret |
| **Returns** | **Dict** |  |  |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_webhook.py#L137){target="_blank" style="float:right; font-size:smaller"}

### handle_webhook_request

>      handle_webhook_request (request, db:fastsql.core.Database, source:str,
>                              handler:Callable,
>                              signature_header:str='X-Webhook-Signature',
>                              idempotency_header:str='X-Idempotency-Key',
>                              event_type_field:str='type',
>                              secret:Optional[str]=None)

*FastHTML route handler for webhook requests.*

Example:
    @app.post('/webhooks/stripe')
    async def stripe_webhook(request):
        return await handle_webhook_request(
            request=request,
            db=get_tenant_db(request),
            source='stripe',
            handler=handle_stripe_event,
            signature_header='X-Stripe-Signature',
            run_in_background=True
        )

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| request |  |  | FastHTML request object |
| db | Database |  | Tenant database instance |
| source | str |  | Webhook source identifier |
| handler | Callable |  | App-specific handler function |
| signature_header | str | X-Webhook-Signature | Header containing signature |
| idempotency_header | str | X-Idempotency-Key | Header containing idempotency key |
| event_type_field | str | type | Field in payload containing event type |
| secret | Optional | None | Optional webhook secret |
| **Returns** | **tuple** |  | **Returns (response_dict, status_code)** |




========================================

FILE: _proc/03_utils_bgtsk.html.md

---
description: Lightweight background task execution for tenant-level operations with
  retry logic and status tracking
output-file: utils_bgtsk.html
title: background task utils

---


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#cell-2 .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## AppJob Model

The [`AppJob`](https://abhisheksreesaila.github.io/fh-saas/utils_bgtsk.html#appjob) model tracks background jobs at the tenant level, similar to [`SystemJob`](https://abhisheksreesaila.github.io/fh-saas/db_host.html#systemjob) in the host database.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_bgtsk.py#L23){target="_blank" style="float:right; font-size:smaller"}

### AppJob

>      AppJob ()

*Model for tenant-level background jobs with retry support*


## BackgroundTaskManager

The [`BackgroundTaskManager`](https://abhisheksreesaila.github.io/fh-saas/utils_bgtsk.html#backgroundtaskmanager) provides a simple interface for submitting and tracking background tasks with automatic retry logic and error handling.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_bgtsk.py#L38){target="_blank" style="float:right; font-size:smaller"}

### BackgroundTaskManager

>      BackgroundTaskManager (db:fastsql.core.Database)

*Lightweight background task manager for tenant-level operations.*

Uses Starlette's BackgroundTask for execution with built-in retry logic,
status tracking, and error handling. All job state is persisted to the
tenant's app_jobs table.

Example:
    ```python
    # Initialize with tenant database
    manager = BackgroundTaskManager(tenant_db)

    # Submit a task
    def sync_transactions(user_id: str, count: int):
        # Your sync logic here
        return {"synced": count}

    job_id, bg_task = manager.submit(
        job_type="transaction_sync",
        task_func=sync_transactions,
        user_id="user123",
        count=100
    )

    # Return with background task in FastHTML route
    return response, bg_task
    ```


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_bgtsk.py#L194){target="_blank" style="float:right; font-size:smaller"}

### BackgroundTaskManager.list_jobs

>      BackgroundTaskManager.list_jobs (job_type:Optional[str]=None,
>                                       status:Optional[str]=None,
>                                       limit:int=100)

*List jobs with optional filtering.*

Args:
    job_type: Filter by job type
    status: Filter by status
    limit: Maximum number of jobs to return

Returns:
    List of AppJob records


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_bgtsk.py#L190){target="_blank" style="float:right; font-size:smaller"}

### BackgroundTaskManager.get_job

>      BackgroundTaskManager.get_job (job_id:str)

*Get job status and details.*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_bgtsk.py#L78){target="_blank" style="float:right; font-size:smaller"}

### BackgroundTaskManager.submit

>      BackgroundTaskManager.submit (job_type:str, task_func:Callable,
>                                    max_retries:int=3, **task_kwargs)

*Submit a new background task for execution.*

Args:
    job_type: Type identifier for the job (e.g., "transaction_sync", "email_send")
    task_func: The function to execute in the background
    max_retries: Maximum number of retry attempts (default: 3)
    **task_kwargs: Keyword arguments to pass to task_func

Returns:
    Tuple of (job_id, BackgroundTask) - job_id for tracking, BackgroundTask for response




========================================

FILE: _proc/05_utils_email.html.md

---
description: Email sending utilities using markdown_merge for clean, maintainable
  email templates
output-file: utils_email.html
title: email utils

---


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#19d20ee4 .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## SMTP Configuration

Configure SMTP settings from environment variables. This works with any SMTP provider including Azure Communication Service via App Registration, SendGrid, AWS SES, Gmail, etc.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L19){target="_blank" style="float:right; font-size:smaller"}

### get_smtp_config

>      get_smtp_config ()

*Get SMTP configuration from environment variables*

Returns:
    Dict with SMTP configuration for markdown_merge

Environment Variables Required:
    SMTP_HOST: SMTP server hostname
    SMTP_PORT: SMTP server port (default: 587)
    SMTP_USER: SMTP authentication username
    SMTP_PASSWORD: SMTP authentication password
    SMTP_MAIL_FROM: Sender email address

Environment Variables Optional:
    SMTP_STARTTLS: Use STARTTLS encryption - True/False (default: True)
    SMTP_SSL: Use SSL instead of STARTTLS - True/False (default: False)

Configuration Examples:
    # Azure Communication Service SMTP
    SMTP_HOST=smtp.azurecomm.net
    SMTP_PORT=587
    SMTP_USER=emailmanager
    SMTP_PASSWORD=<app-registration-token>
    SMTP_MAIL_FROM=DoNotReply@finxplorer.com
    SMTP_STARTTLS=True
    SMTP_SSL=False

Raises:
    ValueError: If required environment variables are missing


## Template Management

Load markdown email templates from the templates directory.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L105){target="_blank" style="float:right; font-size:smaller"}

### load_template

>      load_template (template_name:str)

*Load markdown email template*

Args:
    template_name: Name of template (e.g. 'welcome', 'invitation', 'password_reset')

Returns:
    Template content as string


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L86){target="_blank" style="float:right; font-size:smaller"}

### get_template_path

>      get_template_path (template_name:str)

*Get path to email template file*

Args:
    template_name: Name of template (e.g. 'welcome', 'invitation', 'password_reset')

Returns:
    Path to template file


## Email Sending Functions

Send emails using markdown_merge with markdown templates.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L118){target="_blank" style="float:right; font-size:smaller"}

### send_email

>      send_email (to_email:str, to_name:str, subject:str, template_name:str,
>                  template_vars:Dict[str,str], test:bool=False,
>                  smtp_config:Optional[Dict[str,Any]]=None)

*Send an email using a markdown template*

Args:
    to_email: Recipient email address
    to_name: Recipient name
    subject: Email subject
    template_name: Name of markdown template (e.g. 'welcome', 'invitation')
    template_vars: Dictionary of variables to substitute in template
    test: If True, print email instead of sending (default: False)
    smtp_config: SMTP configuration dict (if None, loads from environment)

Returns:
    Dict with status and details

Example:
    send_email(
        to_email='user@example.com',
        to_name='John Doe',
        subject='Welcome!',
        template_name='welcome',
        template_vars={
            'user_name': 'John',
            'tenant_name': 'Acme Corp',
            'dashboard_url': 'https://app.example.com/dashboard',
            'to_email': 'user@example.com'
        }
    )


## Batch Email Sending

Send the same email to multiple recipients with personalized content.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L223){target="_blank" style="float:right; font-size:smaller"}

### send_batch_emails

>      send_batch_emails (recipients:List[Dict[str,str]], subject:str,
>                         template_name:str,
>                         template_vars_list:List[Dict[str,str]],
>                         test:bool=False, pause:float=0.2,
>                         smtp_config:Optional[Dict[str,Any]]=None)

*Send personalized emails to multiple recipients*

Args:
    recipients: List of dicts with 'email' and 'name' keys
    subject: Email subject (same for all recipients)
    template_name: Name of markdown template
    template_vars_list: List of variable dicts (one per recipient)
    test: If True, print emails instead of sending
    pause: Seconds to pause between sends (default: 0.2)
    smtp_config: SMTP configuration dict (if None, loads from environment)

Returns:
    List of result dicts

Example:
    send_batch_emails(
        recipients=[
            {'email': 'user1@example.com', 'name': 'Alice'},
            {'email': 'user2@example.com', 'name': 'Bob'}
        ],
        subject='Welcome!',
        template_name='welcome',
        template_vars_list=[
            {'user_name': 'Alice', 'tenant_name': 'Acme', ...},
            {'user_name': 'Bob', 'tenant_name': 'Acme', ...}
        ]
    )


## Convenience Template Functions

High-level functions for common email types with pre-defined templates.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L333){target="_blank" style="float:right; font-size:smaller"}

### send_welcome_email

>      send_welcome_email (to_email:str, to_name:str, user_name:str,
>                          tenant_name:str, dashboard_url:str, test:bool=False)

*Send welcome email to new user*

Args:
    to_email: User's email address
    to_name: User's full name for email header
    user_name: User's display name for template
    tenant_name: Tenant name
    dashboard_url: URL to dashboard
    test: If True, print email instead of sending

Returns:
    Result dict from send operation


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L369){target="_blank" style="float:right; font-size:smaller"}

### send_invitation_email

>      send_invitation_email (to_email:str, to_name:str, inviter_name:str,
>                             tenant_name:str, invitation_url:str,
>                             test:bool=False)

*Send invitation email to join tenant*

Args:
    to_email: Invitee's email address
    to_name: Invitee's name for email header
    inviter_name: Name of person sending invitation
    tenant_name: Tenant name
    invitation_url: URL with invitation token
    test: If True, print email instead of sending

Returns:
    Result dict from send operation


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_email.py#L405){target="_blank" style="float:right; font-size:smaller"}

### send_password_reset_email

>      send_password_reset_email (to_email:str, to_name:str, user_name:str,
>                                 reset_url:str, test:bool=False)

*Send password reset email*

Args:
    to_email: User's email address
    to_name: User's full name for email header
    user_name: User's display name for template
    reset_url: Password reset URL with token
    test: If True, print email instead of sending

Returns:
    Result dict from send operation




========================================

FILE: _proc/06_utils_log.html.md

---
output-file: utils_log.html
title: log utils

---


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Tenant Context

Thread-safe context variables for tenant_id, user_id, and request_id that propagate across async boundaries.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L25){target="_blank" style="float:right; font-size:smaller"}

### TenantContext

>      TenantContext (tenant_id:Optional[str]=None, user_id:Optional[str]=None,
>                     request_id:Optional[str]=None)

*Context manager for setting tenant/user/request context*

Example:
    with TenantContext(tenant_id='tenant_123', user_id='user_456'):
        # All logging within this block includes tenant/user context
        some_operation()


::: {#c100d316 .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L59){target="_blank" style="float:right; font-size:smaller"}

### get_context

>      get_context ()

*Get current context variables*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L34){target="_blank" style="float:right; font-size:smaller"}

### TenantContext.__init__

>      TenantContext.__init__ (tenant_id:Optional[str]=None,
>                              user_id:Optional[str]=None,
>                              request_id:Optional[str]=None)

*Initialize self.  See help(type(self)) for accurate signature.*


::: {#427e2a5d .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## Database Handler

Queue-based database handler for non-blocking log writes. Mock-friendly design for testing.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L68){target="_blank" style="float:right; font-size:smaller"}

### DatabaseHandler

>      DatabaseHandler (db_connection=None, batch_size:int=20)

*Non-blocking database log handler with queue*

Collects log records in a queue for batch processing.
Mock-friendly: use write_log() directly in tests.


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L133){target="_blank" style="float:right; font-size:smaller"}

### DatabaseHandler.clear_logs

>      DatabaseHandler.clear_logs ()

*Clear logs (for testing)*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L127){target="_blank" style="float:right; font-size:smaller"}

### DatabaseHandler.get_logs

>      DatabaseHandler.get_logs (level:Optional[str]=None)

*Get collected logs (for testing)*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L87){target="_blank" style="float:right; font-size:smaller"}

### DatabaseHandler.write_log

>      DatabaseHandler.write_log (level:str, message:str,
>                                 operation:Optional[str]=None,
>                                 status:str='info', **kwargs)

*Write log record to database*

Args:
    level: Log level (INFO, ERROR, WARNING)
    message: Log message
    operation: Operation name (for db_operation logs)
    status: Operation status (success, error, info)
    **kwargs: Additional fields (tenant_id, user_id, etc.)


## FastHTML Integration

Use `@app.before` to set TenantContext once per request:

```python
from fasthtml.common import *
from fh_saasutils_log import TenantContext, DatabaseHandler
import uuid

app = FastHTML()
log_handler = DatabaseHandler(get_host_db())

@app.before
def setup_logging_context(request, session):
    """Set tenant context for every request"""
    tenant_id = session.get('tenant_id')  # From auth
    user_id = session.get('user_id')
    request_id = request.headers.get('X-Request-ID', str(uuid.uuid4()))
    
    ctx = TenantContext(tenant_id, user_id, request_id)
    ctx.__enter__()
    request.state.tenant_ctx = ctx
    request.state.log_handler = log_handler

@app.after
def cleanup_logging_context(request, response):
    """Clean up context after request completes"""
    if hasattr(request.state, 'tenant_ctx'):
        request.state.tenant_ctx.__exit__(None, None, None)
    return response

# Routes automatically have context
@app.get('/users')
async def get_users(request):
    users = await fetch_users()  # Logs include tenant_id
    return users
```

## Logging Decorators

Clean decorator wrappers for automatic logging without cluttering utility functions.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L234){target="_blank" style="float:right; font-size:smaller"}

### log_db_operation

>      log_db_operation (operation_type:str='QUERY',
>                        handler:Optional[__main__.DatabaseHandler]=None)

*Decorator for logging database operations*

Args:
    operation_type: Type of operation (SELECT, INSERT, UPDATE, DELETE)
    handler: Database handler (if None, uses global handler)

Example:
    @log_db_operation('INSERT', handler=log_handler)
    def create_user(conn, user_id, email):
        conn.execute("INSERT INTO users...")
        return user_id


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L263){target="_blank" style="float:right; font-size:smaller"}

### log_api_call

>      log_api_call (method:str='GET',
>                    handler:Optional[__main__.DatabaseHandler]=None)

*Decorator for logging API calls*

Args:
    method: HTTP method (GET, POST, PUT, DELETE)
    handler: Database handler (if None, uses global handler)

Example:
    @log_api_call('POST', handler=log_handler)
    async def create_user_endpoint(request):
        return {'status': 'created'}


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_log.py#L291){target="_blank" style="float:right; font-size:smaller"}

### log_background_task

>      log_background_task (task_name:str,
>                           handler:Optional[__main__.DatabaseHandler]=None)

*Decorator for logging background tasks*

Args:
    task_name: Name of background task (e.g. 'data_import', 'email_batch')
    handler: Database handler (if None, uses global handler)

Example:
    @log_background_task('data_import', handler=log_handler)
    async def import_csv(file_path):
        return {'rows_imported': 1000}




========================================

FILE: _proc/10_utils_sync.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#82b3a01c .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## Sync Orchestration

High-level pipeline combining API fetch, Polars transformation, and database upsert.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sync.py#L17){target="_blank" style="float:right; font-size:smaller"}

### sync_external_data

>      sync_external_data (client:fh_saas.utils_graphql.GraphQLClient,
>                          query_template:str, variables:dict,
>                          items_path:list[str], cursor_path:list[str],
>                          table_name:str, key_col:str, db_uri:str,
>                          column_map:dict=None, type_map:dict=None,
>                          has_next_path:list[str]=None, batch_size:int=5000)

*Sync external data from GraphQL API to database.*

End-to-end pipeline:
1. Fetch paginated data from GraphQL (streaming generator)
2. Transform each batch with Polars (rename, type conversion)
3. Upsert batch to database (staging table pattern)
4. Track progress (total records, batches)

Memory efficient: Processes one page at a time, never loads full dataset.

Args:
    client: GraphQL client instance
    query_template: GraphQL query with pagination
    variables: Query variables
    items_path: JSONPath to data items
    cursor_path: JSONPath to cursor
    table_name: Target table name
    key_col: Primary key column
    db_uri: Database connection string
    column_map: Optional column renaming
    type_map: Optional type conversions
    has_next_path: Optional hasNextPage path
    batch_size: Records per batch

Returns:
    Dict with sync stats: {'total_records': 10000, 'batches': 10}

Example:
    ```python
    from fh_saas.utils_api import AsyncAPIClient, bearer_token_auth
    from fh_saas.utils_graphql import GraphQLClient
    import polars as pl

    async with AsyncAPIClient(
        'https://api.example.com/graphql',
        auth_headers=bearer_token_auth('TOKEN')
    ) as api_client:

        client = GraphQLClient(api_client)

        stats = await sync_external_data(
            client=client,
            query_template='''
                query($cursor: String) {
                    users(after: $cursor, first: 1000) {
                        nodes { user_id_val name_str email_addr }
                        pageInfo { hasNextPage endCursor }
                    }
                }
            ''',
            variables={'cursor': None},
            items_path=['data', 'users', 'nodes'],
            cursor_path=['data', 'users', 'pageInfo', 'endCursor'],
            has_next_path=['data', 'users', 'pageInfo', 'hasNextPage'],
            table_name='users',
            key_col='user_id',
            db_uri='sqlite:///app.db',
            column_map={
                'user_id_val': 'user_id',
                'name_str': 'name',
                'email_addr': 'email'
            },
            type_map={
                'user_id': pl.Int64
            }
        )

        print(f"Synced {stats['total_records']} records in {stats['batches']} batches")
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| client | GraphQLClient |  | Initialized GraphQL client |
| query_template | str |  | GraphQL query with $cursor variable |
| variables | dict |  | Initial variables (e.g., {'cursor': None}) |
| items_path | list |  | Path to data list in response |
| cursor_path | list |  | Path to next cursor |
| table_name | str |  | Target database table |
| key_col | str |  | Primary key for upsert |
| db_uri | str |  | Database connection string |
| column_map | dict | None | Optional column renaming |
| type_map | dict | None | Optional type conversions |
| has_next_path | list | None | Optional hasNextPage path |
| batch_size | int | 5000 | Max rows per batch (pagination page size) |
| **Returns** | **Dict** |  |  |


## Incremental Sync Helper

Sync only records updated after a specific timestamp.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_sync.py#L142){target="_blank" style="float:right; font-size:smaller"}

### sync_incremental

>      sync_incremental (client:fh_saas.utils_graphql.GraphQLClient,
>                        query_template:str, last_sync_time:str,
>                        items_path:list[str], cursor_path:list[str],
>                        table_name:str, key_col:str, db_uri:str,
>                        column_map:dict=None, type_map:dict=None,
>                        has_next_path:list[str]=None)

*Incremental sync: fetch only records updated after last sync.*

Args:
    client: GraphQL client
    query_template: Query with $last_sync variable
    last_sync_time: ISO timestamp of last sync
    items_path: Path to data items
    cursor_path: Path to cursor
    table_name: Target table
    key_col: Primary key
    db_uri: Database URI
    column_map: Optional column mapping
    type_map: Optional type conversions
    has_next_path: Optional hasNextPage path

Returns:
    Dict with stats: {'total_records': 100, 'batches': 2, 'last_sync_time': '2024-01-16T10:00:00Z'}

Example:
    ```python
    # Query with $last_sync filter
    query = '''
        query($cursor: String, $last_sync: DateTime!) {
            users(after: $cursor, where: {updated_at: {_gt: $last_sync}}) {
                nodes { id name updated_at }
                pageInfo { hasNextPage endCursor }
            }
        }
    '''

    stats = await sync_incremental(
        client=client,
        query_template=query,
        last_sync_time='2024-01-15T10:00:00Z',
        items_path=['data', 'users', 'nodes'],
        cursor_path=['data', 'users', 'pageInfo', 'endCursor'],
        table_name='users',
        key_col='id',
        db_uri='sqlite:///app.db'
    )
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| client | GraphQLClient |  | Initialized GraphQL client |
| query_template | str |  | GraphQL query with $cursor and $last_sync variables |
| last_sync_time | str |  | ISO timestamp (e.g., '2024-01-15T10:00:00Z') |
| items_path | list |  | Path to data list |
| cursor_path | list |  | Path to cursor |
| table_name | str |  | Target table |
| key_col | str |  | Primary key |
| db_uri | str |  | Database connection |
| column_map | dict | None | Optional column map |
| type_map | dict | None | Optional type map |
| has_next_path | list | None | Optional hasNextPage path |
| **Returns** | **Dict** |  |  |




========================================

FILE: _proc/09_utils_polars_mapper.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#c05b7eb2 .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## Polars Mapping & Database Write

High-performance JSON-to-database pipeline using Polars for vectorized transformations and staging tables for bulk upserts.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_polars_mapper.py#L17){target="_blank" style="float:right; font-size:smaller"}

### map_and_upsert

>      map_and_upsert (df:polars.dataframe.frame.DataFrame, table_name:str,
>                      key_col:str, db_uri:str, column_map:dict=None,
>                      unnest_cols:list[str]=None)

*Map JSON data to database columns and upsert using staging table pattern.*

Performance Strategy (Staging Table Pattern):
1. Write to temporary staging table (fast bulk insert)
2. Execute SQL INSERT ... ON CONFLICT for upsert (database-native, vectorized)
3. Drop staging table (cleanup)

This is 10-100x faster than row-by-row upserts for large datasets.

Args:
    df: Polars DataFrame with JSON data
    table_name: Target table (must already exist)
    key_col: Primary key for ON CONFLICT resolution
    db_uri: Database connection string
    column_map: Optional column renaming {json_col: db_col}
    unnest_cols: Optional list of nested columns to flatten

Example:
    ```python
    import polars as pl

    # JSON from API
    json_data = [
        {'user_id_val': 1, 'ABC_1': 'Alice', 'extra': 'ignore'},
        {'user_id_val': 2, 'ABC_1': 'Bob', 'extra': 'ignore'}
    ]

    # Convert to DataFrame
    df = pl.DataFrame(json_data)

    # Map and upsert
    map_and_upsert(
        df=df,
        table_name='users',
        key_col='user_id',
        db_uri='sqlite:///app.db',
        column_map={'user_id_val': 'user_id', 'ABC_1': 'name'}
    )
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| df | DataFrame |  | The raw Polars DataFrame from JSON |
| table_name | str |  | Target database table name |
| key_col | str |  | Primary key column for conflict resolution |
| db_uri | str |  | SQLAlchemy connection string (e.g., 'sqlite:///db.db' or 'postgresql://...') |
| column_map | dict | None | Optional rename map {json_key: db_col} |
| unnest_cols | list | None | List of Struct columns to flatten |


## Helper: Apply Schema Transformations

Type conversions for common API data formats (ISO dates, boolean strings, numeric strings).

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_polars_mapper.py#L140){target="_blank" style="float:right; font-size:smaller"}

### apply_schema

>      apply_schema (df:polars.dataframe.frame.DataFrame, type_map:dict)

*Apply explicit type conversions to DataFrame columns.*

Args:
    df: Polars DataFrame
    type_map: Dict mapping column names to Polars dtypes

Returns:
    DataFrame with converted types

Example:
    ```python
    df = pl.DataFrame({
        'created_at': ['2024-01-15', '2024-01-16'],
        'is_active': ['true', 'false'],
        'amount': ['123.45', '678.90']
    })

    df = apply_schema(df, {
        'created_at': pl.Date,
        'is_active': pl.Boolean,
        'amount': pl.Float64
    })
    ```

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| df | DataFrame | Input DataFrame |
| type_map | dict | Column name -> Polars dtype (e.g., {'created_at': pl.Date, 'is_active': pl.Boolean}) |
| **Returns** | **DataFrame** |  |




========================================

FILE: _proc/11_utils_blog.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#7b93bf0c .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## post loader

Load markdown files with YAML frontmatter from a directory.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_blog.py#L31){target="_blank" style="float:right; font-size:smaller"}

### PostLoader

>      PostLoader (posts_dir:str)

*Load and parse markdown blog posts from filesystem*

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| posts_dir | str | Directory containing .md files |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_blog.py#L38){target="_blank" style="float:right; font-size:smaller"}

### PostLoader.load_posts

>      PostLoader.load_posts ()

*Load all markdown posts from directory.*

Returns list of post dicts sorted by date (newest first).
Each post contains: title, date, slug, body, categories, author, series.

Example:
    ```python
    loader = PostLoader('blog/posts')
    posts = loader.load_posts()

    for post in posts:
        print(f"{post['title']} - {post['slug']}")
    ```


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_blog.py#L78){target="_blank" style="float:right; font-size:smaller"}

### PostLoader.get_post

>      PostLoader.get_post (slug:str)

*Get single post by slug.*

Example:
    ```python
    post = loader.get_post('bg0010')
    if post:
        print(post['title'])
    ```

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| slug | str |  |
| **Returns** | **Optional** | **URL slug (e.g., 'my-post')** |


## markdown renderer

Convert markdown to HTML with extensions for SEO-friendly output.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_blog.py#L93){target="_blank" style="float:right; font-size:smaller"}

### MarkdownEngine

>      MarkdownEngine ()

*Render markdown to HTML with SEO extensions*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_blog.py#L114){target="_blank" style="float:right; font-size:smaller"}

### MarkdownEngine.render

>      MarkdownEngine.render (content:str)

*Convert markdown to HTML.*

        Returns HTML string with proper semantic tags for SEO.

        Example:
            ```python
            engine = MarkdownEngine()
            html = engine.render('# Hello

This is **bold**.')
            print(html)  # <h1>Hello</h1><p>This is <strong>bold</strong>.</p>
            ```

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| content | str |  |
| **Returns** | **str** | **Markdown content** |


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_blog.py#L130){target="_blank" style="float:right; font-size:smaller"}

### MarkdownEngine.get_toc

>      MarkdownEngine.get_toc ()

*Get table of contents HTML from last render.*

        Must call render() first. Returns empty string if no headings.

        Example:
            ```python
            engine = MarkdownEngine()
            html = engine.render('# Title
## Section 1
## Section 2')
            toc = engine.get_toc()
            print(toc)  # <ul><li><a href="#section-1">Section 1</a>...</li></ul>
            ```


## FastHTML Integration Example

Basic pattern for server-side rendering with FastHTML:

```python
from fasthtml.common import *
from fh_saas.utils_blog import PostLoader, MarkdownEngine

app = FastHTML()
loader = PostLoader('blog/posts')
engine = MarkdownEngine()

@app.get('/blog')
def blog_index():
    posts = loader.load_posts()
    return Titled('Blog',
        *[Article(
            H2(A(p['title'], href=f"/blog/{p['slug']}")),
            P(p['description']),
            Small(p['date'].strftime('%Y-%m-%d') if p['date'] else '')
        ) for p in posts]
    )

@app.get('/blog/{slug}')
def blog_post(slug: str):
    post = loader.get_post(slug)
    if not post:
        return 'Post not found', 404
    
    html_content = engine.render(post['body'])
    toc = engine.get_toc()
    
    return Titled(post['title'],
        Article(
            NotStr(toc),  # Table of contents
            NotStr(html_content)  # Rendered markdown
        )
    )
```



========================================

FILE: _proc/12_utils_seo.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#58adaa42 .cell}
``` {.python .cell-code}
from nbdev.showdoc import show_doc
```
:::


## meta tag generator

Generate SEO-optimized `<head>` tags for blog posts.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_seo.py#L13){target="_blank" style="float:right; font-size:smaller"}

### generate_head_tags

>      generate_head_tags (title:str, description:str, url:str,
>                          image_url:Optional[str]=None,
>                          article_published:Optional[datetime.datetime]=None,
>                          article_modified:Optional[datetime.datetime]=None,
>                          author:Optional[str]=None)

*Generate meta tags for SEO.*

Returns list of (tag_name, attributes_dict) tuples for FastHTML components.
Includes standard, OpenGraph, and Twitter Card tags.

Example:
    ```python
    from fasthtml.common import *

    tags = generate_head_tags(
        title='My Blog Post',
        description='Learn about Python',
        url='https://example.com/blog/my-post',
        image_url='https://example.com/image.jpg'
    )

    # Use in FastHTML app
    @app.get('/blog/my-post')
    def post():
        return Html(
            Head(
                *[Meta(**attrs) if tag == 'meta' else Link(**attrs) 
                  for tag, attrs in tags]
            ),
            Body('...')
        )
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| title | str |  | Page title |
| description | str |  | Page description (150-160 chars optimal) |
| url | str |  | Canonical URL |
| image_url | Optional | None | OpenGraph image URL |
| article_published | Optional | None | Publication date |
| article_modified | Optional | None | Last modified date |
| author | Optional | None | Author name |
| **Returns** | **List** |  |  |


## sitemap generator

Generate XML sitemap for search engine crawlers.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_seo.py#L100){target="_blank" style="float:right; font-size:smaller"}

### generate_sitemap_xml

>      generate_sitemap_xml (posts:List[Dict], base_url:str,
>                            blog_path:str='/blog')

*Generate XML sitemap for blog posts.*

Returns sitemap XML string with proper structure and lastmod dates.

Example:
    ```python
    from fasthtml.common import *
    from fh_saas.utils_blog import PostLoader

    app = FastHTML()
    loader = PostLoader('blog/posts')

    @app.get('/sitemap.xml')
    def sitemap():
        posts = loader.load_posts()
        xml = generate_sitemap_xml(
            posts=posts,
            base_url='https://example.com',
            blog_path='/blog'
        )
        return Response(xml, media_type='application/xml')
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| posts | List |  | List of posts from PostLoader |
| base_url | str |  | Base URL (e.g., 'https://example.com') |
| blog_path | str | /blog | Blog path prefix |
| **Returns** | **str** |  |  |


## rss feed generator

Generate RSS 2.0 feed for blog subscribers.

---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_seo.py#L159){target="_blank" style="float:right; font-size:smaller"}

### generate_rss_xml

>      generate_rss_xml (posts:List[Dict], blog_title:str, blog_description:str,
>                        base_url:str, blog_path:str='/blog')

*Generate RSS 2.0 feed for blog posts.*

Returns RSS XML string for feed readers (Feedly, etc.).

Example:
    ```python
    from fasthtml.common import *
    from fh_saas.utils_blog import PostLoader

    app = FastHTML()
    loader = PostLoader('blog/posts')

    @app.get('/rss.xml')
    def rss():
        posts = loader.load_posts()[:20]  # Latest 20 posts
        xml = generate_rss_xml(
            posts=posts,
            blog_title='My Blog',
            blog_description='Tech tutorials and insights',
            base_url='https://example.com'
        )
        return Response(xml, media_type='application/xml')
    ```

|    | **Type** | **Default** | **Details** |
| -- | -------- | ----------- | ----------- |
| posts | List |  | List of posts from PostLoader |
| blog_title | str |  | Blog title |
| blog_description | str |  | Blog description |
| base_url | str |  | Base URL |
| blog_path | str | /blog | Blog path prefix |
| **Returns** | **str** |  |  |


## FastHTML Integration Example

Complete SEO setup with FastHTML:

```python
from fasthtml.common import *
from fh_saas.utils_blog import PostLoader, MarkdownEngine
from fh_saas.utils_seo import generate_head_tags, generate_sitemap_xml, generate_rss_xml

app = FastHTML()
loader = PostLoader('blog/posts')
engine = MarkdownEngine()

@app.get('/blog/{slug}')
def blog_post(slug: str):
    post = loader.get_post(slug)
    if not post:
        return 'Post not found', 404
    
    # Generate SEO tags
    tags = generate_head_tags(
        title=post['title'],
        description=post['description'] or post['body'][:160],
        url=f"https://example.com/blog/{slug}",
        image_url=post.get('image'),
        article_published=post['date'],
        author=post.get('author')
    )
    
    # Render markdown
    html_content = engine.render(post['body'])
    
    return Html(
        Head(
            Title(post['title']),
            *[Meta(**attrs) if tag == 'meta' else Link(**attrs) 
              for tag, attrs in tags]
        ),
        Body(
            Article(NotStr(html_content))
        )
    )

@app.get('/sitemap.xml')
def sitemap():
    posts = loader.load_posts()
    xml = generate_sitemap_xml(posts, 'https://example.com')
    return Response(xml, media_type='application/xml')

@app.get('/rss.xml')
def rss():
    posts = loader.load_posts()[:20]
    xml = generate_rss_xml(
        posts=posts,
        blog_title='My Blog',
        blog_description='Tech tutorials',
        base_url='https://example.com'
    )
    return Response(xml, media_type='application/xml')
```



========================================

FILE: _proc/13_utils_workflow.html.md

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Workflow Class

A minimal wrapper for executing a sequence of steps. Provides syntactic sugar for readable code - just executes callables in order.

::: {#88658265 .cell}
``` {.python .cell-code}
from nbdev.showdoc import *
```
:::


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_workflow.py#L11){target="_blank" style="float:right; font-size:smaller"}

### Workflow

>      Workflow (steps:List[Callable])

*Execute a list of callables sequentially. Minimal wrapper for code readability.*


---

[source](https://github.com/abhisheksreesaila/fh-saas/blob/main/fh_saas/utils_workflow.py#L18){target="_blank" style="float:right; font-size:smaller"}

### Workflow.execute

>      Workflow.execute ()

*Execute all steps in order*




========================================
